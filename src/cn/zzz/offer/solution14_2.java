package cn.zzz.offer;

/**
 * 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），
 * 每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？
 *
 * 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
 *
 * 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
 *
 * 输入: 2
 * 输出: 1
 * 解释: 2 = 1 + 1, 1 × 1 = 1
 *
 * 来源：力扣（LeetCode）
 * 链接：https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof
 * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 */
public class solution14_2 {

    /**
     * 大数求余解法：
     * 大数越界： 当 a 增大时，最后返回的 3^a
     * 大小以指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。
     * 大数求余问题： 在仅使用 int32 类型存储的前提下，正确计算 x^a
     * 对p求余（即 x^a ⊙ p ）的值。
     *
     * 解决方案：循环求余、快速幂求余，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：
     *
     * (xy) ⊙ p=[(x ⊙ p)(y ⊙ p)]⊙ p
     *
     * @param n
     * @return
     */
    public int cuttingRope(int n) {
        if(n <= 3) return n - 1;
        long res=1L;
        int p=(int)1e9+7;
        //贪心算法，优先切三，其次切二
        while(n>4){
            res=res*3%p;
            n-=3;
        }
        //出来循环只有三种情况，分别是n=2、3、4
        return (int)(res*n%p);
    }

    /**
     * 当 n≤3 时，按照规则应不切分，但由于题目要求必须剪成 m>1 段，因此必须剪出一段长度为 1 的绳子，即返回 n - 1。
     * 当 n>3 时，求 n 除以 3 的 整数部分 a 和 余数部分 b （即 n = 3a + b），并分为以下三种情况（设求余操作符号为 "⊙" ）：
     * 当 b = 0 时，直接返回 3^a ⊙ 1000000007；
     * 当 b = 1 时，要将一个 1+3 转换为 2+2，因此返回 (3^{a-1} × 4) ⊙ 1000000007；
     * 当 b = 2 时，返回 (3^a × 2) ⊙ 1000000007。
     * @param n
     * @return
     */
    public int cuttingRope1(int n) {
        if(n <= 3) return n - 1;
        int b = n % 3, p = 1000000007;
        long rem = 1, x = 3;
        for(int a = n / 3 - 1; a > 0; a /= 2) {
            if(a % 2 == 1) rem = (rem * x) % p;
            x = (x * x) % p;
        }
        if(b == 0) return (int)(rem * 3 % p);
        if(b == 1) return (int)(rem * 4 % p);
        return (int)(rem * 6 % p);
    }
}
